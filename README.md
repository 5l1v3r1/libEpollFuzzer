# libEpollFuzzer - fuzzing async apps from kernel and up
A server running on Linux is a user space process, communicating with the kernel via syscalls such as listen, socket, accept, close, shutdown, send, recv, epoll_wait, epoll_ctl, etc.

The user space "pulls" events from the kernel in batches, via calls to epoll_wait. Instead of pulling from an actual kernel, `libEpollFuzzer` lets you pull from fuzzing data generated by LLVM fuzzers (libFuzzer).

libEpollFuzzer implements the Linux epoll syscalls atop libFuzzer. This allows you to link against these mocked syscalls, and rapidly stress test your entire server software very thoroughly while sanitizers like AddressSanitizer monitors your code for bugs.

Tests can be made entirely deterministic, or iteratively loop over an infinite amount of data.

## Data consumption?
Data is passed with function us_fuzzer_set_data(data, length) and a callback for data exhaustion can be set with us_fuzzer_on_data_exhaustion(cb), so that graceful shutdown after consuming all data can be done.

## In practise

test.cpp:
```c++
#include "epoll_fuzzer.h"

void test() {
  // run your server here, listen and start the event-loop
}

// register this deterministic test case
epoll_fuzzer_deterministic_case(test);
```

Compile it as an LLVM fuzzing case.
